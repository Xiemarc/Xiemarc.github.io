<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="php基础," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="PHP字符串处理函数addcslashes — 为字符串里面的部分字符添加反斜线转义字符addslashes — 用指定的方式对字符串里面的字符进行转义bin2hex — 将二进制数据转换成十六进制表示chop — rtrim() 的别名函数chr — 返回一个字符的ASCII码chunk_split — 按一定的字符长度将字符串分割成小块convert_cyr_string — 将斯拉夫语字符转">
<meta property="og:type" content="article">
<meta property="og:title" content="我的总结">
<meta property="og:url" content="http://yoursite.com/2016/08/10/我的总结-1/index.html">
<meta property="og:site_name" content="Marc |">
<meta property="og:description" content="PHP字符串处理函数addcslashes — 为字符串里面的部分字符添加反斜线转义字符addslashes — 用指定的方式对字符串里面的字符进行转义bin2hex — 将二进制数据转换成十六进制表示chop — rtrim() 的别名函数chr — 返回一个字符的ASCII码chunk_split — 按一定的字符长度将字符串分割成小块convert_cyr_string — 将斯拉夫语字符转">
<meta property="og:updated_time" content="2016-09-07T13:13:27.350Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的总结">
<meta name="twitter:description" content="PHP字符串处理函数addcslashes — 为字符串里面的部分字符添加反斜线转义字符addslashes — 用指定的方式对字符串里面的字符进行转义bin2hex — 将二进制数据转换成十六进制表示chop — rtrim() 的别名函数chr — 返回一个字符的ASCII码chunk_split — 按一定的字符长度将字符串分割成小块convert_cyr_string — 将斯拉夫语字符转">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/08/10/我的总结-1/"/>

  <title> 我的总结 | Marc | </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Marc |</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">我的一生划船不用桨，全靠浪。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-PHP " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                我的总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T21:51:05+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="PHP字符串处理函数"><a href="#PHP字符串处理函数" class="headerlink" title="PHP字符串处理函数"></a>PHP字符串处理函数</h3><p>addcslashes — 为字符串里面的部分字符添加反斜线转义字符<br>addslashes — 用指定的方式对字符串里面的字符进行转义<br>bin2hex — 将二进制数据转换成十六进制表示<br>chop — rtrim() 的别名函数<br>chr — 返回一个字符的ASCII码<br>chunk_split — 按一定的字符长度将字符串分割成小块<br>convert_cyr_string — 将斯拉夫语字符转换为别的字符<br>convert_uudecode — 解密一个字符串<br>convert_uuencode — 加密一个字符串<br><a id="more"></a><br>count_chars — 返回一个字符串里面的字符使用信息<br>crc32 — 计算一个字符串的crc32多项式<br>crypt — 单向散列加密函数<br>echo — 用以显示一些内容<br>explode — 将一个字符串用分割符转变为一数组形式<br>fprintf — 按照要求对数据进行返回，并直接写入文档流<br>get_html_translation_table — 返回可以转换的HTML实体<br>hebrev — 将Hebrew编码的字符串转换为可视的文本<br>hebrevc — 将Hebrew编码的字符串转换为可视的文本<br>html_entity_decode — htmlentities ()函数的反函数，将HTML实体转换为字符<br>htmlentities — 将字符串中一些字符转换为HTML实体<br>htmlspecialchars_decode —htmlspecialchars()函数的反函数，将HTML实体转换为字符<br>htmlspecialchars — 将字符串中一些字符转换为HTML实体<br>implode — 将数组用特定的分割符转变为字符串<br>join — 将数组转变为字符串，implode()函数的别名<br>levenshtein — 计算两个词的差别大小<br>localeconv — 获取数字相关的格式定义<br>ltrim — 去除字符串左侧的空白或者指定的字符<br>md5_file — 将一个文件进行MD5算法加密<br>md5 — 将一个字符串进行MD5算法加密<br>metaphone — 判断一个字符串的发音规则<br>money_format — 按照参数对数字进行格式化的输出<br>nl_langinfo — 查询语言和本地信息<br>nl2br — 将字符串中的换行符“\n”替换成“<br>”<br>number_format — 按照参数对数字进行格式化的输出<br>ord — 将一个ASCII码转换为一个字符<br>parse_str — 把一定格式的字符串转变为变量和值<br>print — 用以输出一个单独的值<br>printf — 按照要求对数据进行显示<br>quoted_printable_decode — 将一个字符串加密为一个8位的二进制字符串<br>quotemeta — 对若干个特定字符进行转义<br>rtrim — 去除字符串右侧的空白或者指定的字符<br>setlocale — 设置关于数字，日期等等的本地格式<br>sha1_file — 将一个文件进行SHA1算法加密<br>sha1 — 将一个字符串进行SHA1算法加密<br>similar_text — 比较两个字符串，返回系统认为的相似字符个数<br>soundex — 判断一个字符串的发音规则<br>sprintf — 按照要求对数据进行返回，但是不输出<br>sscanf — 可以对字符串进行格式化<br>str_ireplace — 像str_replace()函数一样匹配和替换字符串，但是不区分大小写<br>str_pad — 对字符串进行两侧的补白<br>str_repeat — 对字符串进行重复组合<br>str_replace — 匹配和替换字符串<br>str_rot13 — 将字符串进行ROT13加密处理<br>str_shuffle — 对一个字符串里面的字符进行随机排序<br>str_split — 将一个字符串按照字符间距分割为一个数组<br>str_word_count — 获取字符串里面的英文单词信息<br>strcasecmp — 对字符串进行大小比较，不区分大小写<br>strchr — 通过比较返回一个字符串的部分strstr()函数的别名<br>strcmp — 对字符串进行大小比较<br>strcoll – 根据本地设置对字符串进行大小比较<br>strcspn — 返回字符连续非匹配长度的值<br>strip_tags — 去除一个字符串里面的HTML和PHP代码<br>stripcslashes — 反转义addcslashes()函数转义处理过的字符串<br>stripos — 查找并返回首个匹配项的位置，匹配不区分大小写<br>stripslashes — 反转义addslashes()函数转义处理过的字符串<br>stristr — 通过比较返回一个字符串的部分，比较时不区分大小写<br>strlen — 获取一个字符串的编码长度<br>strnatcasecmp — 使用自然排序法对字符串进行大小比较，不区分大小写<br>strnatcmp — 使用自然排序法对字符串进行大小比较<br>strncasecmp — 对字符串的前N个字符进行大小比较，不区分大小写<br>strncmp — 对字符串的前N个字符进行大小比较<br>strpbrk — 通过比较返回一个字符串的部分<br>strpos — 查找并返回首个匹配项的位置<br>strrchr — 通过从后往前比较返回一个字符串的部分<br>strrev — 将字符串里面的所有字母反向排列<br>strripos — 从后往前查找并返回首个匹配项的位置，匹配不区分大小写<br>strrpos – 从后往前查找并返回首个匹配项的位置<br>strspn — 匹配并返回字符连续出现长度的值<br>strstr — 通过比较返回一个字符串的部分<br>strtok — 用指定的若干个字符来分割字符串<br>strtolower — 将字符串转变为小写<br>strtoupper –将字符串转变为大写<br>strtr — 对字符串比较替换<br>substr_compare — 对字符串进行截取后的比较<br>substr_count — 计算字符串中某字符段的出现次数<br>substr_replace — 对字符串中的部分字符进行替换<br>substr — 对字符串进行截取<br>trim — 去除字符串两边的空白或者指定的字符<br>ucfirst — 将所给字符串的第一个字母转换为大写<br>ucwords — 将所给字符串的每一个英文单词的第一个字母变成大写<br>vfprintf — 按照要求对数据进行返回，并直接写入文档流<br>vprintf — 按照要求对数据进行显示<br>vsprintf — 按照要求对数据进行返回，但是不输出<br>wordwrap — 按照一定的字符长度分割字符串</p>
<ul>
<li>有很好的<code>开源意识</code>,<code>开放平台</code>思想</li>
<li><code>Libraries for developersV3.39</code>:众多开源效果集合–&gt;国外–&gt;只是提供了地址</li>
<li><code>android开源项目汇总</code>:众多开源效果集合–&gt;国人–&gt;只是提供了地址</li>
<li><code>baseAnimation</code>:众多开源效果–&gt;针对动画效果–&gt;国人–&gt;开源的.需要效果的时候.要自行去找对应的代码</li>
<li><code>http://www.23code.com/</code>–&gt;开源项目集合网站</li>
<li><code>http://a.code4app.com/</code>–&gt;开源项目集合网站</li>
<li>一些demo的集合–&gt;5000</li>
<li><code>深度理解</code>,<code>广度知道</code></li>
</ul>
<p>###Volley</p>
<ul>
<li>回忆xutils:<code>快速开发型框架</code>,DbUtils(orm),ViewUtils(ioc),HttpUtils,BitmapUtils</li>
<li>其他的快速开发型框架:andBase,thinkandroid,loonandroid,dhroid</li>
<li>orm:对象关系型映射<ul>
<li>db:create table t_table(_id integer primary key autoincret…);</li>
<li>insert–&gt;save(obj)</li>
</ul>
</li>
<li>ioc:控制反转 <ul>
<li>Obj obj = new Obj();</li>
<li>对象的实例化,不用new关键字就可以了吧.</li>
</ul>
</li>
<li>为什么要讲volley?<ul>
<li>因为它是google出的,google 在2013 i/o大会上提出来的.</li>
<li>而且在几个项目里面已经看到了它的身影</li>
</ul>
</li>
<li>google公司为什么会去搞一个volley框架?<ul>
<li><ol>
<li>用户开启一个activity,然后加载网络,这个时候.如果用户点击了finish按钮.activity被销毁了–&gt;网络请求和activity的生命周期是应该联动起来的.</li>
</ol>
</li>
<li><ol>
<li>listview加载图片的情况比较多.如果用户快速的去滑动listview–&gt;getView-&gt;快速的加载图片,用户停止操作的时候.其实真正现实的图片最多就几张—&gt;图片应该缓存起来(内存 +本地 )</li>
</ol>
</li>
<li><ol>
<li>如果用户打开了一个activity,用户旋转了一下屏幕.activity会旋转–&gt;生命周期重走了–&gt;网络请求缓存</li>
</ol>
</li>
<li><ol>
<li>之前我们的网络请求,httpurlconnection,httpclient,asynctask(api)–&gt;android sdk–&gt;封装性不够好.1000个开发者就有1000种使用方式–&gt;不够统一</li>
</ol>
</li>
<li><ol>
<li>理念很容易理解,是开源的.</li>
</ol>
</li>
</ul>
</li>
<li>volley是啥?<ul>
<li>是一种<code>通信框架</code>,和xutils中的HttpUtils,BitmapUtils</li>
</ul>
</li>
</ul>
<p>###Volley两个核心类</p>
<ul>
<li>Request:一个请求<ul>
<li>StringRequest:请求的时候直接回来一个String</li>
<li>JsonObjectRequest:请求的时候直接回来一个JsonObject</li>
<li>JsonArrayRequest:请求的时候直接回来一个JsonArray</li>
<li>ImageRequest:请求的时候直接回来一个Bitmap</li>
<li>自定义请求:一会我们会结合gson</li>
</ul>
</li>
<li>ImageLoader:图片的加载器</li>
<li>NetWorkImageView:继承了imageView,对ImageView进行了拓展</li>
<li>RequestQueue:请求队列.<br>###一步一步学习</li>
</ul>
<p>###JsonObject取值</p>
<ul>
<li>String origin = response.getString(“origin”);// 方式一<ul>
<li>这个如果没有对应的key会抛异常.需要异常处理</li>
</ul>
</li>
<li>String origin = response.optString(“origin”);// 方式二    <ul>
<li>这个如果没有对应的key不会抛异常.会返回一个默认值</li>
<li>optString:默认值””</li>
<li>optInt:默认值 0</li>
<li>比如有的实体bean属性很多.我们不喜欢去建议对应的XXX.class的时候.可以使用JsonObject里面的这个方法;<br>###图片</li>
</ul>
</li>
<li>大图片的处理:<ul>
<li>大图片处理的核心</li>
<li>核心类:BitmapFactory.Options</li>
<li>核心方法:<ul>
<li>decodeOptions.inJustDecodeBounds = true;–&gt;得到图片的宽度以及高度,不需要把图片加载到内存 10M</li>
<li>decodeOptions.inJustDecodeBounds = false;–&gt;真正去加载图片</li>
<li>decodeOptions.inSampleSize–&gt;采样率–&gt;不同的框架有不同的核心算法<ul>
<li>特点:2 4 8 –&gt;取值最好使用2的指数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>图片的加载</li>
<li>图片的缓存</li>
</ul>
<p>###框架找SampleSize的方式</p>
<ol>
<li><p>volley</p>
<pre><code>static int findBestSampleSize(
    int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
double wr = (double) actualWidth / desiredWidth;
double hr = (double) actualHeight / desiredHeight;
double ratio = Math.min(wr, hr);
float n = 1.0f;
while ((n * 2) &lt;= ratio) {
    n *= 2;
}
return (int) n;
}
</code></pre></li>
<li><p>Xutils</p>
<pre><code> public static int calculateInSampleSize(BitmapFactory.Options options, int maxWidth, int maxHeight) {
final int height = options.outHeight;
final int width = options.outWidth;
int inSampleSize = 1;

if (width &gt; maxWidth || height &gt; maxHeight) {
    if (width &gt; height) {
        inSampleSize = Math.round((float) height / (float) maxHeight);
    } else {
        inSampleSize = Math.round((float) width / (float) maxWidth);
    }

    final float totalPixels = width * height;

    final float maxTotalPixels = maxWidth * maxHeight * 2;

    while (totalPixels / (inSampleSize * inSampleSize) &gt; maxTotalPixels) {
        inSampleSize++;
    }
}
return inSampleSize;
</code></pre><p> }</p>
</li>
<li><p>uil_imageLoader</p>
<pre><code>public static int computeMinImageSampleSize(ImageSize srcSize) {
final int srcWidth = srcSize.getWidth();
final int srcHeight = srcSize.getHeight();
final int targetWidth = maxBitmapSize.getWidth();
final int targetHeight = maxBitmapSize.getHeight();

final int widthScale = (int) Math.ceil((float) srcWidth / targetWidth);
final int heightScale = (int) Math.ceil((float) srcHeight / targetHeight);

return Math.max(widthScale, heightScale); // max
}

public static int computeImageSampleSize(ImageSize srcSize, ImageSize targetSize, ViewScaleType viewScaleType,
    boolean powerOf2Scale) {
final int srcWidth = srcSize.getWidth();
final int srcHeight = srcSize.getHeight();
final int targetWidth = targetSize.getWidth();
final int targetHeight = targetSize.getHeight();

int scale = 1;

switch (viewScaleType) {
    case FIT_INSIDE:
        if (powerOf2Scale) {
            final int halfWidth = srcWidth / 2;
            final int halfHeight = srcHeight / 2;
            while ((halfWidth / scale) &gt; targetWidth || (halfHeight / scale) &gt; targetHeight) { // ||
                scale *= 2;
            }
        } else {
            scale = Math.max(srcWidth / targetWidth, srcHeight / targetHeight); // max
        }
        break;
    case CROP:
        if (powerOf2Scale) {
            final int halfWidth = srcWidth / 2;
            final int halfHeight = srcHeight / 2;
            while ((halfWidth / scale) &gt; targetWidth &amp;&amp; (halfHeight / scale) &gt; targetHeight) { // &amp;&amp;
                scale *= 2;
            }
        } else {
            scale = Math.min(srcWidth / targetWidth, srcHeight / targetHeight); // min
        }
        break;
}

if (scale &lt; 1) {
    scale = 1;
}
scale = considerMaxTextureSize(srcWidth, srcHeight, scale, powerOf2Scale);

return scale;
</code></pre><p> }</p>
</li>
</ol>
<p>###内存缓存</p>
<ul>
<li>1.内存缓存的核心:<ul>
<li>存:就有很多的考虑</li>
<li>取:只需要知道唯一的key就可以了</li>
</ul>
</li>
<li>2.选择什么样的<code>存储结构/容器/集合</code>?Map<string,bitmap></string,bitmap></li>
<li>3.4种引用级别什么意思?<ul>
<li>强引用:我们平时使用的集合(arraylist,hashmap,hashset),即使内存oom,也不会去回收对象;</li>
<li>软应用:使用SoftRefrence去包装一个对象,内存不足的时候去回收对象,尽量保证不oom</li>
<li>弱应用:基本没有用过</li>
<li>虚引用:形同虚设,同样没有用过</li>
</ul>
</li>
<li>4.<code>删除策略/算法</code>,我们定义的<code>存储结构</code>,不能继续缓存图片的时候.需要进行清理<ul>
<li>LRU:最近最少使用,Least Recently Used,其实就是按照访问顺序排序</li>
<li>删除使用次数最少的:</li>
<li>删除占用体积最大:</li>
</ul>
</li>
<li><ol>
<li>在很久之前(2,3年)前做图片的缓存基本都是使用软应用,但是在2.3之后.google文档明确指出了软应用做缓存的一些不足.建议我们使用LruCache.class;</li>
</ol>
</li>
<li>6.举例说明<code>删除策略</code>的使用场景<ul>
<li>LRU:电影海报图删除策略–&gt;和时间有关系(时效性)</li>
<li>删除使用次数最少的:–&gt;和时间没有关系而且大小差不多</li>
<li>删除占用体积最大:空间比较宝贵的情况</li>
</ul>
</li>
</ul>
<p>###LruCache的使用:</p>
<blockquote>
<p>一个工具方法,提供了基于<code>Lru缓存策略</code>的<code>强引用</code>的内存缓存,<code>存储结构使用的LinkedHashmap</code></p>
</blockquote>
<ul>
<li><p>LinkedHashmap使用</p>
<ul>
<li>LinkedHashmap和Hashmap区别:在构造方法里面多了3个参数</li>
<li>3个参数的意义:<ul>
<li>initialCapacity:初始化容器大小 16</li>
<li>loadFactor:负载因子 </li>
<li>accessOrder:<ul>
<li>true:LinkedHash内部会排序–&gt;按照访问顺序排序–&gt;这个也是为什么LruCache使用LinkedHashmap做存储结构的原因</li>
<li>false:按照插入顺序去排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LruCache在什么地方可以找到?</p>
<ul>
<li>在高版本的sdk里面有.</li>
<li>在v4包中有提供.</li>
</ul>
</li>
<li>LruCache的使用<ol>
<li>告知缓存的具体大小</li>
<li>覆写sizeOf方法,具体大小需要和我们定义的maxsize单位统一<br>###网络请求的取消</li>
</ol>
</li>
<li><p>httpclient:</p>
<pre><code>DefaultHttpClient httpClient = new DefaultHttpClient();
ClientConnectionManager connectionManager = httpClient.getConnectionManager();// 拿到连接管理器
connectionManager.shutdown();
</code></pre></li>
<li>httpurlconnection:</li>
<li>volley:多级别取消<ul>
<li>取消某一个请求:</li>
<li>取消请求的队列:</li>
</ul>
</li>
</ul>
<pre><code>//2. 创建RequestQueue
RequestQueue queue = Volley.newRequestQueue(MainActivity.this);
//3. 发起请求
queue.add(stringRequest);
//取消单个请求
stringRequest.cancel();//取消一个请求
//取消所有请求
queue.cancelAll(null);//取消请求队列里面所有的方法
//取消置顶tag的请求
queue.cancelAll(&quot;tag1&quot;);//取消tag为tag1的一个请求
//请求添加tag--&gt;tag的目的就是为了反查
stringRequest.setTag(&quot;tag1&quot;);
//两个不同的请求可以设置同一个tag
stringRequest.setTag(&quot;tag1&quot;);
//    stringRequest1.setTag(&quot;tag1&quot;);
</code></pre><ul>
<li>xutils:xutils其实也是封装的httpclient,所以网络请求取消的方式和httpClient一样</li>
<li><p>生命周期的联动</p>
<pre><code>StringRequest req1 = null;
StringRequest req2 = null;
StringRequest req3 = null;
StringRequest req4 = null;
StringRequest req5 = null;

req1.setTag(this.getClass().getSimpleName());
req2.setTag(this.getClass().getSimpleName());
req3.setTag(this.getClass().getSimpleName());
req4.setTag(this.getClass().getSimpleName());
req5.setTag(this.getClass().getSimpleName());

// 取消对应activity里面所有的请求
RequestQueue queue = VolleyTools.getInstance(MainActivity.this).getQueue();
queue.cancelAll(this.getClass().getSimpleName());// MainActivity
</code></pre></li>
</ul>
<p>###架构</p>
<ul>
<li><p>b/s架构:绘图说明</p>
</li>
<li><p>mvc:设计思想</p>
<ul>
<li>M:model  javaBean domain</li>
<li>V:view  xml view adapter</li>
<li>C:Ctroller  Activity Fragment </li>
</ul>
</li>
<li><p>mvp:设计思想</p>
<ul>
<li>M:model</li>
<li>V:View </li>
<li>P:Presenter</li>
</ul>
</li>
<li><p>四层架构:自我总结</p>
<ul>
<li>数据提供层–&gt;dataProvider:提供数据</li>
<li>数据持久层–&gt;data persistent–&gt;sqlite ,sp,file</li>
<li>业务逻辑层–&gt;servcie logic</li>
<li>ui展现层</li>
</ul>
</li>
</ul>
<p>###gzip </p>
<blockquote>
<p>一种压缩格式,一种压缩方式,可以对<code>网络传输的数据</code>进行压缩.减少网络传输的大小</p>
</blockquote>
<ul>
<li><p>为什么需要压缩?</p>
<ul>
<li>减少体积,提高传输速度,提高用户体验</li>
</ul>
</li>
<li><p>浏览器发送器请求的过程?</p>
<ul>
<li>1.发送请求头:<code>Accept-Encoding:gzip</code></li>
<li>2.服务器压缩数据,返回数据,在响应头里面添加<code>Content-Encoding:gzip</code></li>
<li>3.客户端,根据Content-Encoding这个响应头,对应解压<ul>
<li>有Content-Encoding:gzip–&gt;gzip解压</li>
<li>没有Content-Encoding:gzip–&gt;标准解压</li>
</ul>
</li>
</ul>
</li>
<li>app使用gzip压缩<ul>
<li>返回的json/xml(文本信息)其实就是个特殊的网页,其实也是可以进行gzip压缩</li>
</ul>
</li>
</ul>
<p>###gzip压缩效果</p>
<blockquote>
<p>通过数据,我们得知,文本的压缩率,大概可以达到70%左右.压缩率很高;</p>
</blockquote>
<p>###gzip压缩的实现</p>
<pre><code>try {
    boolean isGzip = false;
    //1.创建httpclient
    DefaultHttpClient httpClient = new DefaultHttpClient();
    //2.创建get请求
    HttpGet get = new HttpGet(&quot;http://httpbin.org/gzip&quot;);
    //① 添加请求头 Accept-Encoding:&quot;gzip, deflate&quot;
    get.addHeader(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
    //3.执行请求
    HttpResponse response = httpClient.execute(get);
    if (response.getStatusLine().getStatusCode() == 200) {
        //② 得到响应头,Content-Encoding:&quot;gzip&quot;
        Header[] headers = response.getHeaders(&quot;Content-Encoding&quot;);
        for (Header header : headers) {
            if (header.getValue().equals(&quot;gzip&quot;)) {//后台server把数据进行了gzip压缩
                isGzip = true;
            }
        }
        String result = &quot;&quot;;
        HttpEntity entity = response.getEntity();
        //③根据是否使用gzip压缩.采取不同的解压方式
        if (isGzip) {
            //④进行gzip的解压
            GZIPInputStream in = new GZIPInputStream(response.getEntity().getContent());
            //in--&gt;string
            result = convertStreamToString(in);
        } else {
            //4.打印结果
            result = EntityUtils.toString(entity);
        }
        System.out.println(&quot;result:&quot; + result);
    }
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><p>###测试请求的地址</p>
<blockquote>
<p><code>http://httpbin.org</code></p>
</blockquote>
<p>###常见的content-type</p>
<ul>
<li>application/x-www-form-urlencoded:表单,key-value</li>
<li>multipart/form-data:二进制,file</li>
<li><strong>application/json</strong> :json,虽然有的服务器直接用<code>text/plain</code>这个请求头没有任何问题.但是很多服务器,必须需要<code>application/json</code>,明确的说.如果是返回json,一定加上<code>application/json</code>,不要用默认的.实际开发遇到了几次这样的问题.或者说.<strong>加上这个请求头肯定是万无一失</strong>;</li>
<li>text/xml :xml</li>
<li>text/plain:普通文本,默认类型</li>
</ul>
<p>###模拟请求插件restClient的使用</p>
<blockquote>
<p>这个是firefox上的一个插件,对应chrome浏览器叫做postman,这个插件主要用作和服务器开发人员联调协议;</p>
</blockquote>
<ul>
<li>key-value:<ul>
<li>1.添加head–&gt;Content-Type</li>
<li>2.传递参数:key=value&amp;key=value</li>
</ul>
</li>
<li>jsonString<ul>
<li>1.添加head</li>
<li>2.传递参数:jsonString</li>
</ul>
</li>
</ul>
<p>###编码.数字摘要.加密.解密</p>
<ul>
<li><p>编码:Base64,urlEncoder/urlDecoder    </p>
<ul>
<li><p>urlEncoder:地址栏不允许中文,传递一些特殊字符 &amp; ?</p>
<pre><code>String url = &quot;http://www.baidu.com?serarch=\&quot;哈哈\&quot;&amp;key=value&quot;;//&amp; ? 
//URLEncoder encode
String encode = URLEncoder.encode(url);
System.out.println(encode);
//URLDecoder decode
String decode = URLDecoder.decode(encode);
System.out.println(decode);
//没有经过encode的字符串.直接decode,会原样输出
String decode2 = URLDecoder.decode(url);
System.out.println(decode2);
</code></pre></li>
<li><p>Base64:把一些对象转换成string,用处:传输的时候不要明文传输</p>
<ul>
<li>上传图片,上传语音</li>
<li><p>如何把一个map存到sp–&gt;Base64支持把byte[]–&gt;String,只需把对象先转换成byte[]就可以存到sp中</p>
<pre><code>ImageView iv = (ImageView) findViewById(R.id.iv);
//1.得到bitmap
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
//2.bitmap--&gt;byte[]
ByteArrayOutputStream out = new ByteArrayOutputStream();
bitmap.compress(CompressFormat.PNG, 100, out);
byte[] bitmapByteArr = out.toByteArray();
//3.使用base64 byte[]--String---&gt;上传到服务器
String bitmapBase64String = Base64.encodeToString(bitmapByteArr, Base64.DEFAULT);

//key-value jsonString

//4.String--&gt;byte[]
byte[] bitmapByteArr2 = Base64.decode(bitmapBase64String, Base64.DEFAULT);
//5.byte[]--&gt;Bitmap --&gt;完成图片的上传
Bitmap bitmapPassed = BitmapFactory.decodeByteArray(bitmapByteArr2, 0, bitmapByteArr2.length);
//6.设置图片到imageView
iv.setImageBitmap(bitmapPassed);
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>数字摘要:md5 sha1</p>
<ul>
<li>md5:密码一般都是需要md5,不可逆,而且1kb的文件和1tb的文件.md5之后.得到的结果长度是一样;</li>
<li>md5作用:或者叫做数字摘要作用–&gt;<strong><code>确定数据未被修改</code></strong> <strong><code>文件的唯一性</code></strong></li>
<li>加盐: 就是在密码的前面加入一些特殊字符%^&amp;&amp;%^&amp;   </li>
<li>sha1:和md5算法不一样.作用一样</li>
<li>android support v4:v4包的版本冲突.就是根据sha1值判断</li>
<li>秒传功能:其实也是根据文件的sha1    </li>
</ul>
</li>
<li><p>加密/解密</p>
</li>
<li>对称加密:只有一把密钥,如果密钥暴露,文件就会被暴露<ul>
<li>des: Data Encryption Standard</li>
<li>aes: Advanced Encryption Standard</li>
<li>特点:加密速度比较快.可以加密比较大的文件</li>
</ul>
</li>
<li>非对称加密:有两把钥匙(密钥对),公钥和私钥,公钥的话给别人.私钥自己保存,;<ul>
<li>RSA</li>
<li>特点:加密速度比慢一些,但是安全系数比较高</li>
<li>秘钥对的话需要程序生成.不能我们自己定义</li>
<li>加密/解密:公钥加密–&gt;私钥解密<ul>
<li><code>public static byte[] encryptByPublicKey(byte[] data, String publicKey)</code>//公钥加密</li>
<li><code>public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey)</code>//私钥解密</li>
</ul>
</li>
<li>加密/解密:私钥加密–&gt;公钥解密<ul>
<li><code>public static byte[] encryptByPrivateKey(byte[] data, String privateKey)</code>//私钥加密</li>
<li>public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey)//公钥解密</li>
</ul>
</li>
<li>数字签名:<strong>确定数据来源的不可否认性</strong>,确定所属关系–&gt;其实就是确定privatekey在哪里.<ul>
<li>签名:<code>public static String sign(byte[] data, String privateKey)</code>//只能使用私钥进行签名</li>
<li>校验:<code>public static boolean verify(byte[] data, String publicKey, String sign)</code></li>
</ul>
</li>
<li>公钥互换:两个人,两个结构,就是说两个密钥对的持有者相互的置换公钥</li>
</ul>
</li>
</ul>
<p>###sqlite db文件加密</p>
<ul>
<li>如果应用的数据很多是来源db文件–&gt;核心数据 </li>
<li>聊天信息–&gt;敏感数据</li>
<li>sqlitecipher<ul>
<li>使用它,应用程序体积会大很多.因为需要引入差不多6m的东西</li>
<li>步骤:<ul>
<li>加入libs</li>
<li>加入assets</li>
<li>注意引擎的初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>###sqlite 数据库表字段巧设计</p>
<ul>
<li>缓存bean的属性比较多–&gt;数据库表的列字段比较—&gt;很繁琐(代码可能需要不停的put put put)</li>
<li>项目的初期,表字段可能增加,减少,以及修改–&gt;都会修改表结构–&gt;所以缓存的数据就没啥用</li>
<li><p>解决方法,我们可以把相关的信息json化之后,保存它的jsonString就可以了</p>
<pre><code>db.execSQL(&quot;CREATE TABLE `&quot; + TABLE_NAME_CINEMA_SIMPLE + &quot;` ( `Id` integer primary key autoincrement, &quot;//
+ &quot;`cityId` varchar(10),&quot; + //
&quot;`cinemaId` varchar(10),&quot; + //
&quot; `cinemaSimpleInfo` varchar(400),&quot; + //这里就是我们jsonString
&quot;`insertDate` varchar(10))&quot;);// /
</code></pre></li>
</ul>
<p>###移动支付</p>
<blockquote>
<p>用户使用移动的设备,完成对所购买商品或者服务的支付功能.远程支付(网上支付,短信支付),近场支付(刷卡,滴卡,pos机)</p>
</blockquote>
<p>###apk集成支付功能</p>
<p>###常见的支付厂商</p>
<ul>
<li><strong>支付宝</strong>:阿里公司,支付宝使用比较多.</li>
<li><strong>微信</strong>:腾讯公司,也是越来越多.</li>
<li>易付宝:</li>
<li>财付通:腾讯公司</li>
<li><strong>银联</strong>:不属于某一个公司</li>
<li>百度钱包:百度</li>
<li>支付宝钱包:阿里的.</li>
<li>快钱:</li>
<li>ping++:整合了很多的支付平台  </li>
</ul>
<p>###支付难不难?</p>
<blockquote>
<p>不难,都是属于第三方的东西.难度不大</p>
</blockquote>
<p>###支付安不安全?</p>
<blockquote>
<p>肯定是安全的.因为这些都是大公司的产品.都有自己的安全策略;</p>
</blockquote>
<p>###做一个支付需要多久?</p>
<ul>
<li>项目评估</li>
<li>支付宝:大概5分钟.</li>
<li>银联支付:大概5分钟.</li>
<li>微信支付:大概10分钟.</li>
</ul>
<p>###支付流程_从生活出发<br>1.选择商品<br>2.选择支付方式<br>3.处理支付结果</p>
<p>###支付流程_从app开发角度(保证可以先完成功能)</p>
<ol>
<li>拼接支付信息,post到服务器;–&gt;request<ol>
<li>支付信息包含支付方式</li>
<li>服务器:是我们自己的服务器</li>
<li>支付协议:<code>http://mobileif.maizuo.com/version3/orderform/order?version=2</code></li>
</ol>
</li>
<li><p>服务器返回<code>支付串码</code>;—&gt;reponse</p>
<pre><code>请求的url(支付协议/确认订单协议):  http://mobileif.maizuo.com/version3/orderform/order?version=2
请求方式:post
post参数形式:jsonString
输入参数:{&quot;goodInfos&quot;:[{&quot;goodCounts&quot;:&quot;1&quot;,&quot;goodExtInfo&quot;:{},&quot;goodIDs&quot;:&quot;361&quot;,&quot;goodType&quot;:&quot;1&quot;}],&quot;loginFlag&quot;:&quot;0&quot;,&quot;mobile&quot;:&quot;18682036558&quot;,&quot;orderId&quot;:&quot;0&quot;,&quot;otherInfo&quot;:{&quot;agentID&quot;:&quot;0-maizuo&quot;,&quot;channelID&quot;:&quot;31&quot;,&quot;clientID&quot;:&quot;31&quot;},&quot;payDatas&quot;:{&quot;discountInfo&quot;:{&quot;activeID&quot;:&quot;0&quot;,&quot;discountID&quot;:&quot;0&quot;,&quot;discountPrice&quot;:&quot;&quot;},&quot;payInfo&quot;:[{&quot;bankType&quot;:&quot;7&quot;,&quot;payCount&quot;:&quot;3200&quot;,&quot;payTicketCount&quot;:&quot;1&quot;,&quot;payType&quot;:&quot;1&quot;}],&quot;payPass&quot;:&quot;&quot;,&quot;returnUrl&quot;:&quot;&quot;,&quot;totalPrice&quot;:&quot;3200&quot;},&quot;processPath&quot;:&quot;1&quot;,&quot;sessionKey&quot;:&quot;mqneaadqapkpkqshxvdj&quot;,&quot;userID&quot;:&quot;200394160&quot;}
输出结果{&quot;result&quot;:&quot;ok&quot;,&quot;payExtInfo&quot;:{&quot;alipayVerifyKey&quot;:&quot;_input_charset=\&quot;UTF-8\&quot;&amp;body=\&quot;卖座网电子影票\&quot;&amp;it_b_pay=\&quot;1h\&quot;&amp;notify_url=\&quot;http%3A%2F%2Fpay.maizuo.com%2FmobileBack.htm\&quot;&amp;out_trade_no=\&quot;201507238712113008\&quot;&amp;partner=\&quot;2088411628331920\&quot;&amp;payment_type=\&quot;1\&quot;&amp;seller_id=\&quot;2088411628331920\&quot;&amp;service=\&quot;mobile.securitypay.pay\&quot;&amp;subject=\&quot;深圳金逸影城沙井店(2D通兑票1张)\&quot;&amp;total_fee=\&quot;32.00\&quot;&amp;sign=\&quot;M0O0Ej5J13A25SAWupc5a6vAGmJnblx2CvuWF2dwFGxMZ%2BxlRWmp%2F6ZDfI8Y%2FFJbjiEqE99MAsKh%0AfIBQqP4Y1TyNkbY0XixQFPgAAqsqwGqYJSDtqUFWRgje%2B8pI1KuxfPE3UcDZs4hxDZoP%2Bdof%2Bldf%0AKQmximUyqT5Crtwj1Ag%3D\&quot;&amp;sign_type=\&quot;RSA\&quot;&quot;},&quot;bankType&quot;:&quot;&quot;,&quot;userId&quot;:&quot;200394160&quot;,&quot;resource&quot;:{&quot;rel&quot;:&quot;view&quot;,&quot;link&quot;:&quot;/orderform/200394160/201507238712113008&quot;},&quot;payType&quot;:&quot;7&quot;,&quot;payUrl&quot;:&quot;&quot;,&quot;orderId&quot;:&quot;201507238712113008&quot;,&quot;uniqueKey&quot;:&quot;D5585vO8624915A11z&quot;,&quot;timeNow&quot;:&quot;1437622208552&quot;}
</code></pre></li>
<li><p>拿着支付串码,调用第三方服务,完成支付–&gt;5分钟</p>
</li>
<li>处理支付结果<ol>
<li>同步返回:支付后通知我们自己的apk</li>
<li>异步通知:支付后通知我们的server</li>
</ol>
</li>
</ol>
<p>###什么是支付串码</p>
<blockquote>
<p>这个是老师自己定义的一个概念.其实就是第三步调用起第三方支付平台<code>核心支付方法所需要的参数</code></p>
</blockquote>
<p>###集成支付宝流程</p>
<ol>
<li>我们自己要和支付宝签约(商户签约).–&gt;运营</li>
<li>秘钥配置–&gt;协助运营完成秘钥的配置(公钥互换),可能程序员会参与</li>
<li><p>集成支付宝–&gt;必须是程序员去做.</p>
<ol>
<li>下载sdk/demo/文档</li>
<li>demo尝试的去运行<ol>
<li>出现了错误:因为缺少运行必须的,DEFAULT_PARTNER,DEFAULT_SELLER,如果1,2步完成的话,我们在这个时候就可以有<code>DEFAULT_PARTNER,DEFAULT_SELLER</code></li>
</ol>
</li>
<li><p>开始集成–&gt;<code>参照移动快捷支付应用集成接入包支付接口接入与使用规则.pdf</code></p>
<ol>
<li>添加jar,alipay.jar</li>
<li>添加lib,alipay_lib</li>
<li>添加了一个activity</li>
<li>添加了一些权限</li>
<li><p>调用支付的核心代码</p>
<pre><code>//    3.调用第三方服务,完成支付
//获取Alipay对象，构造参数为当前Activity和Handler实例对象
AliPay alipay = new AliPay(MainActivity.this, mHandler);
//调用pay方法，将订单信息传入
//同步返回    取消操作  支付成功  支付失败(网络异常)
String payResult = alipay.pay(alipayVerifyKey);
</code></pre></li>
<li><p>处理支付结果—&gt;支付宝处理支付结果用的handler机制</p>
<pre><code>/**---------------demo里面处理支付结果的代码---------------**/

/*Result result = new Result((String) msg.obj);
switch (msg.what) {
case RQF_PAY:
case RQF_LOGIN: {
    Toast.makeText(ExternalPartner.this, result.getResult(), Toast.LENGTH_SHORT).show();

}
    break;
default:
    break;
}
*/
/**---------------老师实际开发处理支付结果的代码---------------**/

/*Result.sResult = (String) msg.obj;
Logger.i(TAG, &quot;strRet:&quot; + Result.sResult);
try {
    String errorMsg = Result.getPayResult();
    Logger.i(TAG, &quot;errorMsg:&quot; + errorMsg);
    if (!&quot;&quot;.equals(errorMsg)) {
        Toast.makeText(getApplicationContext(), errorMsg, 0).show();
        if (&quot;操作成功&quot;.equals(errorMsg)) {
            payOk();//支付成功可以调到订单界面
        } else {
            payFail();//可以弹出对话框进行重复支付
        }
    }
} catch (Exception e) {
    e.printStackTrace();
    if (!PayActivity.this.isFinishing()) {
        BaseHelper.showDialog(PayActivity.this, &quot;提示&quot;, Result.sResult + &quot;，如有疑问请联系卖座客服：4001808400&quot;, R.drawable.infoicon);
    }
}
</code></pre><p> }<br> };*/</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>###支付宝demo分析</p>
<ul>
<li>查看demo发现他的<code>支付串码</code>,是在客户端生成的.这个和老师所讲的.支付串码由服务器生成.有出入;</li>
<li><p>为了不暴露我们privatekey,我们应该把生成支付串码的过程交给我们的服务器</p>
<pre><code>/**---------------生成支付串码的过程  begin---------------**/
Log.i(&quot;ExternalPartner&quot;, &quot;onItemClick&quot;);
String info = getNewOrderInfo(position);
//其实下面的操作应该是server端去完成.不然我们会暴露privatekey---begin---add_by_billy
//所有我们会把info的具体内容用jsonString的形式.post给server进行签名.然后返回签名后的结果---add_by_billy
String sign = Rsa.sign(info, Keys.PRIVATE);
sign = URLEncoder.encode(sign);
info += &quot;&amp;sign=\&quot;&quot; + sign + &quot;\&quot;&amp;&quot; + getSignType();
Log.i(&quot;ExternalPartner&quot;, &quot;start pay&quot;);
// start the pay.
Log.i(TAG, &quot;info = &quot; + info);
//其实下面的操作应该是server端去完成.不然我们会暴露privatekey---end---add_by_billy
final String orderInfo = info;
/**---------------生成支付串码的过程  end---------------**/
</code></pre><p>###支付串码_老师自己定义的一个概念</p>
<blockquote>
<p>支付串码就是调用第三方应用的时候需要的一些核心的参数</p>
</blockquote>
</li>
</ul>
<p>###银联支付</p>
<ul>
<li>银联支付,就<code>只需要一个交易流水号</code>就可以,而且看代码比较简单,重点是,<code>银联强制要求生产支付串码的过程必须交给我们的服务端</code></li>
<li>集成形式<ul>
<li>内嵌apk形式:就是把一个apk放到我们的assets目录下面–&gt;老的方式</li>
<li>新版本so库形式:在libs下面就有很多的so库.已经不需要在assets目录下面放置apk</li>
</ul>
</li>
<li>模式:<ul>
<li>测试模式:银联会给我们提供一个测试环境+提供了一个银联的账号/密码</li>
<li>正式模式:就必须使用真实的账号/密码</li>
</ul>
</li>
<li>运行demo看效果:</li>
<li><p>集成步骤:</p>
<ul>
<li>1.添加libs里面相关的东西;</li>
<li><p>2.添加activity配置</p>
<pre><code>&lt;activity
android:name=&quot;com.unionpay.uppay.PayActivityEx&quot;
android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;
android:excludeFromRecents=&quot;true&quot;
android:label=&quot;@string/app_name&quot;
android:screenOrientation=&quot;portrait&quot;
android:windowSoftInputMode=&quot;adjustResize&quot; /&gt;
&lt;activity
    android:name=&quot;com.unionpay.uppay.PayActivity&quot;
    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;
    android:excludeFromRecents=&quot;true&quot;
    android:screenOrientation=&quot;portrait&quot; /&gt;
</code></pre></li>
<li><p>3.添加权限</p>
</li>
</ul>
</li>
</ul>
<pre><code>        &lt;!-- uupay --&gt;
        &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;
        &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
        &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;
* 4.调用核心的支付方法

        //拿着支付串码
        System.out.println(&quot;alipayVerifyKey:&quot; + alipayVerifyKey);
        //    3.调用第三方服务,完成支付
        // “00” – 银联正式环境
        // “01” – 银联测试环境，该环境中不发生真实交易
        //tn 交易流水号  
        UPPayAssistEx.startPayByJAR(MainActivity.this, PayActivity.class, null, null,
                alipayVerifyKey, &quot;00&quot;);
* 5.处理支付结果


        /**---------------银联处理支付结果---------------**/
        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        /*************************************************
         * 
         * 步骤4：处理银联手机支付控件返回的支付结果
         * 
         ************************************************/
        if (data == null) {
            return;
        }

        String msg = &quot;&quot;;
        /*
         * 支付控件返回字符串:success、fail、cancel 分别代表支付成功，支付失败，支付取消
         */
        String str = data.getExtras().getString(&quot;pay_result&quot;);
        if (str.equalsIgnoreCase(&quot;success&quot;)) {
            msg = &quot;支付成功！&quot;;
        } else if (str.equalsIgnoreCase(&quot;fail&quot;)) {
            msg = &quot;支付失败！&quot;;
        } else if (str.equalsIgnoreCase(&quot;cancel&quot;)) {
            msg = &quot;用户取消了支付&quot;;
        }

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(&quot;支付结果通知&quot;);
        builder.setMessage(msg);
        builder.setInverseBackgroundForced(true);
        // builder.setCustomTitle();
        builder.setNegativeButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        });
        builder.create().show();
        }
</code></pre><p>###微信支付</p>
<ul>
<li>直接运行demo,发现最后提示错误,发现工程下面有一个debug.keystore</li>
<li><p>想要运行.可以如下操作</p>
<ul>
<li>自定义keystore</li>
<li>或者直接导出的时候用工程下面的debug.keystore去签名</li>
</ul>
</li>
<li><p>微信支付的安全策略之一:必须包名和keystore签名需要一致</p>
</li>
<li>demo里面定义的步骤<ul>
<li>一、获取 access_token</li>
<li>二、生成预支付订单,需要用到第一步的access_token,得到的是prepayId</li>
<li>三、调起微信支付</li>
<li>四、处理支付结果</li>
<li>这个时候一看.感觉微信支付很难.但是我们看到demo里面这样的一句话<code>注意：不能hardcode在客户端，建议genPackage这个过程由服务器端完成</code>,所以,其实我们的微信支付,一、二步骤为了安全起见应该交给Server</li>
</ul>
</li>
</ul>
<ul>
<li><p>实际开发,只需关心3,4步就可以</p>
<ul>
<li><p>三、调起微信支付</p>
<pre><code>/**
 * @author Administrator
 * 支付的时候真正关心的数据
 * 这个对象是我自己封装的.和微信支付的sdk没有关系
 */
public class WXPayData {
private String sign_method;
private String timestamp;
private String noncestr;
private String partnerid;
private String app_signature;
private String prepayid;
private String package1;
private String appid;
}

//核心支付方法
private void sendPayReq(WXPayData info) {
api = WXAPIFactory.createWXAPI(this, info.getAppid());
PayReq req = new PayReq();
req.appId = info.getAppid();
req.partnerId = info.getPartnerid();
req.prepayId = info.getPrepayid();//预支付id
req.nonceStr = info.getNoncestr();//32位内的随机串，防重发
req.timeStamp = String.valueOf(info.getTimestamp());//时间戳，为 1970 年 1 月 1 日 00:00 到请求发起时间的秒数
req.packageValue = info.getPackage1();
req.sign = info.getApp_signature();
// 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信
api.sendReq(req);
</code></pre><p>}</p>
</li>
<li>四、处理支付结果:微信支付支付的回调是在<code>net.sourceforge.simcpux.wxapi.WXPayEntryActivity.class</code>里面</li>
</ul>
</li>
</ul>
<pre><code>@Override
public void onResp(BaseResp resp) {
Log.d(TAG, &quot;onPayFinish, errCode = &quot; + resp.errCode);

if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(R.string.app_tip);
    builder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode)));
    builder.show();
}
}
</code></pre><p>###安全码策略</p>
<blockquote>
<p>安全码的组成规则为：Android签名证书的sha1值+“;”+packagename(即:数字签名+分号+包名)</p>
</blockquote>
<ul>
<li>作用:确定apk的唯一性</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/php基础/" rel="tag">#php基础</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/10/自定义view/" rel="next" title="自定义view">
                <i class="fa fa-chevron-left"></i> 自定义view
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/10/接口和自定义观察者模式/" rel="prev" title="接口和自定义观察者模式">
                接口和自定义观察者模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Xiemarc" />
          <p class="site-author-name" itemprop="name">Xiemarc</p>
          <p class="site-description motion-element" itemprop="description">android开发</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Xiemarc" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1750579585/home?wvr=5&lf=reg" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/u012721933" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-blog"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP字符串处理函数"><span class="nav-number">1.</span> <span class="nav-text">PHP字符串处理函数</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiemarc</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
